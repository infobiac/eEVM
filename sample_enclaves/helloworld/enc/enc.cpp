// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include <stdio.h>
#include "evm/simpleglobalstate.h"
#include "include/processor.h"
#include "include/opcode.h"



// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "helloworld_t.h"

std::vector<uint8_t> create_bytecode(const std::string& s)
{
  std::vector<uint8_t> code;
  constexpr uint8_t mdest = 0x0;
  const uint8_t rsize = s.size() + 1;

  // Store each byte in evm memory
  uint8_t mcurrent = mdest;
  for (const char& c : s)
  {
    code.push_back(evm::Opcode::PUSH1);
    code.push_back(c);
    code.push_back(evm::Opcode::PUSH1);
    code.push_back(mcurrent++);
    code.push_back(evm::Opcode::MSTORE8);
  }

  // Return
  code.push_back(evm::Opcode::PUSH1);
  code.push_back(rsize);
  code.push_back(evm::Opcode::PUSH1);
  code.push_back(mdest);
  code.push_back(evm::Opcode::RETURN);

  return code;
}

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
void enclave_new_tx(evm::Address)
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    // evm::SimpleGlobalState gs;
    // std::string hello_world("Hello world!");



    fprintf(stdout, "Enclave initiated\n");


    // Create global state
    evm::SimpleGlobalState gs;

    // Deploy contract to global state
    const evm::AccountState contract = gs.create(to, 0, code);

    // Create transaction
    evm::NullLogHandler ignore;
    evm::Transaction tx(sender, ignore);

    // Create processor
    evm::Processor p(gs);

    // Execute code. All execution is associated with a transaction. This
    // transaction is called by sender, executing the code in contract, with empty
    // input (and no trace collection)
    const evm::ExecResult e = p.run(tx, sender, contract, {}, 0, nullptr);
    const char* response = reinterpret_cast<const char*>(e.output.data());

    fprintf(stdout, "%s\n", response);


    // Call back into the host
    oe_result_t result = host_return_tx();
    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "Call to host_helloworld failed: result=%u (%s)\n",
            result,
            oe_result_str(result));
    }
}
